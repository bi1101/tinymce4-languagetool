/**
 *
 * Copyright, KnowZero
 * Released under Apache 2.0 License.
 * Version 0.36-Alpha
 *
 * Contributing: https://github.com/KnowZero/tinymce4-languagetool
 */

/**
 * LanguageTool is a JavaScript library for language checking and grammar correction.
 * @param {Object} lt_set - The configuration settings for LanguageTool.
 * @param {jQuery} $ - The jQuery library.
 * @constructor
 */
var LanguageTool = function LanguageTool(lt_set, $) {

    // Declare Variables
    var sgevent = {}; // Events that can be called
    var sgfunc = {}; // Store functions
    var sgcheck = {}; // Active storage of changes
    var sgdocevents = {}; // Events called on document
    var sgewinevents = {}; // Events caleld on editor window

    // Universal Storage
    // Initialize an object named sgstore
    var sgstore = {
        // html: An object to store HTML related data
        html: {},

        // text: An object to store text related data
        text: {},

        // obj: An object to store various objects
        obj: {},

        // lt: An object to store language tool related data
        lt: {},

        // lock: An object to store lock related data
        lock: {},

        // run: An array to store run related data
        run: [],

        // contextmenu: An object to store context menu related data
        contextmenu: {},

        // ignore: An object to store ignore related data
        ignore: {
            // once: An object to store data to be ignored once
            once: {},

            // all: An object to store data to be ignored all the time
            all: {},

            // rule: An object to store rule related data to be ignored
            rule: {},

            // categories: An object to store category related data to be ignored
            categories: {}
        },

        // queue: An array of arrays to store queue related data
        queue: [[], [], []],

        // dqueue: An object to store dqueue related data
        dqueue: {},

        // iaqueue: An object to store iaqueue related data
        iaqueue: {},

        // progress: An array to store progress related data
        progress: [0, 0, 0, 0],

        // issues: An object to store issue related data
        issues: {},

        // viewport_process: A string to store the status of viewport processing
        viewport_process: 'disabled',

        // enabled: A boolean to store the enabled status
        enabled: true
    };

    var timerRunner = 0; // Timer countdown for remote URL (counts upwards though)

    var lastActive = 0; // Last activity for hibernation
    var lastRun = 0; // Keep track of when time last ran in epoch
    var newLineCheck = 0; // Check if new line has been made
    var listInstances = {};
    var timerSet = 0;
    var timerOff = 0;
    var win;
    var winPos = 0;
    var last_winPos = 0;

    var lt_remoteUrl = lt_set['lt_url'] || "https://languagetool.org/api/v2/check";
    var lt_remoteTimer = lt_set['lt_timer'] || 10000; // DO NOT CHANGE UNLESS YOU USE YOUR OWN URL!



    var lt_setLanguage = lt_set['lt_lang'] || "en-US";

    var lt_setMode = lt_set['lt_mode'] || "new_sentence";

    var lt_setHighlight = lt_set['lt_highlight'] || {};
    var lt_debugLevel = lt_set['lt_debug'] || 0;
    var lt_ignoreCallback = lt_set['lt_ignore_callback'] || function () { };
    var lt_monopolizeHighlightContextMenu = lt_set['lt_monopolize_highlight_contextmenu'] || true;
    var lt_highlightClick = lt_set['lt_highlight_click'] || "right";
    var lt_fullMessage = lt_set['lt_full_message'] || false;
    var lt_showProgressBar = lt_set['lt_show_progress_bar'] || true;
    var lt_ignoreBlockTags = lt_set['lt_ignore_block_tags'] || {};
    var lt_ignoreSelector = lt_set['lt_ignore_selector'];

    var lt_maxInstances = (lt_set['lt_max_instances'] || 2);
    var lt_sizeOfInstances;

    var lt_inactive = 0;

    var lastnode;

    sgstore.viewport_process = lt_set['lt_viewport_process'] || 'disabled';

    sgstore['ignore']['all'] = lt_set['lt_ignore_words'] || {};
    sgstore['ignore']['rule'] = lt_set['lt_ignore_rules'] || {};


    //Css Class for different type of grammar error
    lt_setHighlight['misspelling'] = lt_setHighlight['misspelling'] || "hlr1";
    lt_setHighlight['grammar'] = lt_setHighlight['grammar'] || "hlg1";
    lt_setHighlight['typographical'] = lt_setHighlight['typographical'] || "hlb1";
    lt_setHighlight['style'] = lt_setHighlight['style'] || "hln1";
    lt_setHighlight['duplication'] = lt_setHighlight['duplication'] || "hlo1";
    lt_setHighlight['inconsistency'] = lt_setHighlight['inconsistency'] || "hlp1";
    lt_setHighlight['other'] = lt_setHighlight['other'] || "hly1";


    // This block of code is designed to protect the public server from accidents

    // Check if the remote URL is the LanguageTool server
    if (/\/\/languagetool\.org/i.test(lt_remoteUrl)) {
        // Set the size of instances to the configured value or 10KB if not configured
        lt_sizeOfInstances = lt_set['lt_size_of_instances'] || (10 * 1024);

        // Check if the hostname of the current window location is github.io or languagetool.org
        if (/(?:^|\.)(?:github\.io|languagetool.org)$/i.test(window.location.hostname)) {
            // No specific action is taken for these hostnames
        } else {
            // If the remote timer is less than 10 seconds, set it to 10 seconds
            if (lt_remoteTimer < 10000) {
                lt_remoteTimer = 10000;
            }
            // Set the maximum number of instances to 1
            lt_maxInstances = 1;
            // If the size of instances is less than 10KB, set it to 10KB
            if (lt_sizeOfInstances < (10 * 1024)) {
                lt_sizeOfInstances = (10 * 1024);
            }
        }
    } else {
        // If the remote URL is not the LanguageTool server, set the size of instances to the configured value or 25KB if not configured
        lt_sizeOfInstances = lt_set['lt_size_of_instances'] || (25 * 1024);
    }

    // Load UI elements


    // Load Stylesheet into UI
    var css_link = $("<link>", {
        rel: "stylesheet",
        type: "text/css",
        href: lt_set['lt_library_path'] + '/include/contextmenu.css'
    });
    css_link.appendTo('head');
    var css_link2 = $("<link>", {
        rel: "stylesheet",
        type: "text/css",
        href: lt_set['lt_library_path'] + '/include/progressbar.css'
    });
    css_link2.appendTo('head');



    // Load ContextMenu into UI
    var context_menu = $('<div id="context-menu-nav"><ul id="context-menu-ul"></ul></div>');
    context_menu.appendTo('body');

    // This function is triggered when the editor is removed
    sgevent['remove'] = function () {
        // Set the timerOff variable to 1, which means the timer is turned off
        timerOff = 1;

        // For each event in sgdocevents (events attached to the document)
        $.each(sgdocevents, function (key, val) {
            // If there is no second argument (no specific element to remove the event from)
            if (val[1] == '') {
                // Remove the event from the document
                $(document).off(val[0], val[2]);
            } else {
                // Remove the event from the specific element in the document
                $(document).off(val[0], val[1], val[2]);
            }
        });

        // For each event in sgewinevents (events attached to the editor window)
        $.each(sgewinevents, function (key, val) {
            // If there is no second argument (no specific element to remove the event from)
            if (val[1] == '') {
                // Remove the event from the document
                $(document).off(val[0], val[2]);
            } else {
                // Remove the event from the specific element in the document
                $(document).off(val[0], val[1], val[2]);
            }
        });
    };

    // This function is triggered when the editor is initialized
    sgevent['init'] = function () {
        // Load a CSS file into the editor
        sgfunc['setcss'].call(this, '/include/languagetool.css');

        // Start the language tool timer
        lt_timer(1);

        // If the mode is set to 'grammar_only', ignore typos
        if (lt_setMode == 'grammar_only') {
            sgstore['ignore']['categories']['TYPOS'] = 1;
        }

        // If the progress bar should be shown, initialize it
        if (lt_showProgressBar == true) {
            sgfunc['progress_init'].call();
        }

        // Get the editor window
        win = $(sgfunc['window'].call());

        // Define what happens when the editor window is scrolled
        sgewinevents.scrollHandler = ['scroll', '', function (e) {
            // Get the scroll position of the window
            winPos = win.scrollTop();

            // Reset the inactivity timer
            lt_inactive = 0;
        }];

        // For each event in sgewinevents
        $.each(sgewinevents, function (key, val) {
            // If there is no second argument
            if (val[1] == '') {
                // Attach the event to the window
                $(sgfunc['window'].call()).on(val[0], val[2]);
            } else {
                // Attach the event to the window with a selector
                $(sgfunc['window'].call()).on(val[0], val[1], val[2]);
            }
        });

        // Define what happens when the mouse button is pressed down in the document
        sgdocevents.contenxtmenu_mousedownHandler = ['mousedown', '', function (e) {
            // If the clicked element is not a child of the element with id "context-menu-nav"
            if (!$(e.target).parents("#context-menu-nav").length > 0) {
                // Get the UUID of the clicked element
                var uuid = $(this).data("ident-uuid");

                // Unlock the clicked element
                sgstore['lock'][uuid] = 0;

                // Hide the element with id "context-menu-nav" over 100 milliseconds
                $("#context-menu-nav").hide(100);
            }
        }];
    };


    // This function is triggered when the mouse button is pressed down
    sgevent['mousedown'] = function (e) {
        // If the event target (the element that was clicked) is not a child of the element with id "context-menu-nav"
        if (!$(e.target).parents("#context-menu-nav").length > 0) {
            // Hide the element with id "context-menu-nav" over 100 milliseconds
            $("#context-menu-nav").hide(100);
        }

        // If the left mouse button was clicked and lt_highlightClick is set to 'left'
        if (lt_highlightClick == 'left' && e.which == 1) {
            // Open the context menu at the location of the event (where the mouse was clicked)
            lt_openContextMenu(e);
        }
    };

    // This function is triggered when the context menu is opened (usually by right-clicking)
    sgevent['contextmenu'] = function (e) {
        // If lt_highlightClick is set to 'right'
        if (lt_highlightClick == 'right') {
            // If lt_monopolizeHighlightContextMenu is true and opening the context menu is successful
            if (lt_monopolizeHighlightContextMenu == true && lt_openContextMenu(e) == 1) {
                // Hide the default context menu
                sgfunc['contextmenu_hide'].call();
                // Prevent the default action (opening the default context menu)
                return false;
            }
        }
        // Allow the default action
        return true;
    };

    // This function is triggered when the content is set
    sgevent['setcontent'] = function (e) {
        // If the mode is not set to 'manual'
        if (lt_setMode != 'manual') {
            // Process the new content
            lt_new_content_process({});
        }
    };

    // This function is triggered when a keydown event occurs
    sgevent['keydown'] = function (e) {
        // If the mode is not set to 'manual'
        if (lt_setMode != 'manual') {
            // Get the key code of the key that was pressed
            var key = e.which || e.keyCode || 0;

            // Get the currently selected node
            var mynode = sgfunc['selectnode'].call();

            // If the key is not an arrow key (codes 37-40 are arrow keys)
            if (!(key >= 37 && key <= 40)) {
                // If the selected node is a span element with a data attribute 'hid'
                if (mynode.nodeName == 'SPAN' && $(mynode).data('hid') != undefined) {
                    // Find the parent of the selected node
                    var mypnode = lt_find_parent_node(mynode);

                    // Get the UUID of the parent node
                    var uuid = $(mypnode).data('UUID');

                    // Get the current bookmark
                    var bm = sgfunc['bookmark'].call();

                    // Replace the span with its inner HTML, effectively removing the span
                    $(mynode).replaceWith($(mynode).html());

                    // Restore the bookmark
                    sgfunc['bookmark'].call(this, bm);
                }
            }

            // If the enter key (code 13) was pressed
            if (key == 13) {
                // Find the parent of the selected node
                var mypnode = lt_find_parent_node(mynode);

                // Get the UUID of the parent node
                var uuid = $(mypnode).data('UUID');

                // Add the the whole doc to the queue
                lt_new_content_process({});

                // If the selected node has a data attribute 'hid'
                if ($(mynode).data('hid') != undefined) {
                    // Remove the data attribute 'hid' from the selected node
                    $(mynode).removeData('hid');

                    // Remove all classes from the selected node
                    $(mynode).removeClass();

                    // Add the class 'lt-highlight-remove' to the selected node
                    $(mynode).addClass('lt-highlight-remove');
                }
            }
        }
    };

    // This function is triggered when a keyup event occurs
    sgevent['keyup'] = function (e) {
        // If the mode is not set to 'manual'
        if (lt_setMode != 'manual') {
            // Set lt_inactive to 0, meaning the language tool is active
            lt_inactive = 0;

            // Get the key code of the key that was released
            var key = e.which || e.keyCode || 0;

            // If the key is not an arrow key (codes 37-40 are arrow keys)
            if (!(key >= 37 && key <= 40)) {
                // Get the currently selected node
                var mynode = sgfunc['selectnode'].call();

                // Find the parent of the selected node
                var mypnode = lt_find_parent_node(mynode);

                // Get the position of the caret (text cursor) within the parent node
                var posCaret = getCaretOffset(mypnode);
                var posSearch = 0;

                // Loop through each child node of the parent node
                $.each(mypnode.childNodes, function (i, cnode) {
                    // Get the length of the text in the current child node
                    var tlength = $(cnode).text().length;

                    // If the current child node is a span element with a data attribute 'hid'
                    if (cnode != undefined && cnode.nodeName == 'SPAN' && $(cnode).data('hid') != undefined) {
                        // If the caret is at the start or end of the span, or if the delete or backspace key was pressed at the start or end of the span
                        if (posCaret == posSearch || (key == 46 && posCaret + 1 == posSearch) || posCaret == posSearch + tlength || (key == 8 && posCaret - 1 == posSearch)) {
                            // Get the UUID of the parent node
                            var uuid = $(mypnode).data('UUID');
                            // Get the current bookmark
                            var bm = sgfunc['bookmark'].call();
                            // Replace the span with its inner HTML, effectively removing the span
                            $(cnode).replaceWith($(cnode).html());
                            // Restore the bookmark
                            sgfunc['bookmark'].call(this, bm);
                        }
                    }

                    // Add the length of the current child node's text to posSearch
                    posSearch += tlength;
                });

                // If posSearch is not equal to posCaret, add the selected node to the inactive queue
                if (posSearch != posCaret) {
                    // Add the the whole doc to the queue
                    lt_new_content_process({});
                }
            }
        }
    };



    // This function is triggered when a key is pressed
    sgevent['keypress'] = function (e) {
        // If the mode is not set to 'manual'
        if (lt_setMode != 'manual') {
            // Get the key code of the pressed key
            var key = e.which || e.keyCode || 0;

            // If the pressed key is a period, exclamation mark, or question mark
            if (key == 46  // .
                || key == 33    // !
                || key == 63    // ?
            ) {
                // Get the selected node (the part of the text that is currently selected)
                var mynode = sgfunc['selectnode'].call();

                // Find the parent node of the selected node
                var mypnode = lt_find_parent_node(mynode);

                // Get the UUID (a unique identifier) of the parent node
                var uuid = $(mypnode).data('UUID');

                // Log some information for debugging purposes
                lt_debug('INFO|ENDSENT=' + mypnode.nodeName + '|' + mynode.nodeName + '|' + uuid, 4);

                // Add the the whole doc to the queue
                lt_new_content_process({});

                // If the selected node has a 'hid' data attribute
                if ($(mynode).data('hid') != undefined) {
                    // Remove the 'hid' data attribute from the selected node
                    $(mynode).removeData('hid');

                    // Remove all classes from the selected node
                    $(mynode).removeClass();

                    // Add the 'lt-highlight-remove' class to the selected node
                    $(mynode).addClass('lt-highlight-remove');
                }
                // If the pressed key is a space or comma
            } else if (key == 32 // SPACE
                || key == 44  // ,
            ) {
                // If the mode is set to 'new_word'
                if (lt_setMode == 'new_word') {
                    // The code in this block is the same as the code in the previous block
                    // It gets the selected node, finds its parent, gets the UUID of the parent,
                    // logs some information, adds the parent to the queue, and removes the 'hid'
                    // data attribute and all classes from the selected node, then adds the
                    // 'lt-highlight-remove' class to the selected node
                    var mynode = sgfunc['selectnode'].call();
                    var mypnode = lt_find_parent_node(mynode);
                    var uuid = $(mypnode).data('UUID');
                    lt_debug('INFO|ENDSENT=' + mypnode.nodeName + '|' + mynode.nodeName + '|' + uuid, 4);
                    // Add the the whole doc to the queue
                    lt_new_content_process({});
                    if ($(mynode).data('hid') != undefined) {
                        $(mynode).removeData('hid');
                        $(mynode).removeClass();
                        $(mynode).addClass('lt-highlight-remove');
                    }
                }
            }
        }
    };


    var manualProcess = function () {
        lt_new_content_process({});
    }


    var setStore = function (key, val) {
        sgstore[key] = val;

    };

    var getStore = function (key, key2) {

        if (key2 == undefined) {
            return sgstore[key];
        } else {
            return sgstore[key][key2];
        }


    };

    var setFunction = function (name, func) {
        sgfunc[name] = func;
    };


    var getEvent = function (name, obj, e) {
        return sgevent[name].call(obj, e);
    };


    var removeRule = function (e) {
        var val = $("#lt_ignoreRulesCfg").val();
        delete (sgstore['ignore']['rule'][val]);
        lt_ignoreCallback.call(this, 'removeRule', val);
        $("#lt_ignoreRulesCfg option:selected").remove();
    };

    var removeWord = function (e) {
        var val = $("#lt_ignoreWordsCfg").val();
        delete (sgstore['ignore']['all'][val]);
        lt_ignoreCallback.call(this, 'removeWord', val);
        $("#lt_ignoreWordsCfg option:selected").remove();
    };

    var setProgress = function (curp, maxp) {
        lt_progress_bar(curp, maxp);
    };

    var nextIssue = function (val) {
        lt_nextIssue(val);
    };

    var setIgnoreDialog = function (val) {
        lt_contextMenuIgnore($('#lt_issueSuggestions').data('ident-UUID'), $('#lt_issueSuggestions').data('ident-HID'), val, 1);
    };

    var setSkipDialog = function () {
        $(sgstore['contextmenu']).removeClass('dialog-highlight').addClass('skip-dialog-highlight'); lt_nextIssue();
    };
    var setAcceptDialog = function (sug, toval) {
        if (sug == undefined) {
            sug = '#lt_issueSuggestions';
            toval = '#lt_issueChangeTo';
        }


        lt_contextMenuClick($(sug).data('ident-UUID'), $(sug).data('ident-HID'), $(toval).val(), 1);
    };


    // Queues


    // This function adds a node to the processing queue
    /**
     * Adds a UUID to the queue in sgstore at the specified level.
     * If the 'enabled' property of sgstore is true and the uuid is not undefined,
     * it stores the text, HTML, and node object in sgcheck, sgstore['html'], and sgstore['obj'] respectively.
     * If the 'viewport_process' property of sgstore is 'disabled', it shows the progress bar.
     * If newline is greater than 0, it sets newLineCheck to newline.
     * Finally, it calls the lt_timer function with 0 as the argument to resume if idle.
     * 
     * @param {string} uuid - The UUID to be added to the queue.
     * @param {Node} mynode - The node object to be stored in sgstore['obj'].
     * @param {number} qlvl - The level at which the UUID should be added to the queue.
     * @param {number} newline - The value to set newLineCheck to if greater than 0.
     */
    function lt_queue(uuid, mynode, qlvl, newline) {
        // Check if the 'enabled' property of sgstore is true and the uuid is not undefined
        if (sgstore['enabled'] == true && uuid != undefined) {
            // Get the text and HTML of the node
            var thtemp = lt_textHTML(mynode);
            // Store the text in sgcheck with the uuid as the key
            sgcheck[uuid] = thtemp['text'];
            // Store the HTML in sgstore with the uuid as the key
            sgstore['html'][uuid] = thtemp['html'];
            // Store the node object in sgstore with the uuid as the key
            sgstore['obj'][uuid] = mynode;
            // If the 'viewport_process' property of sgstore is 'disabled', show the progress bar
            if (sgstore.viewport_process == 'disabled') { lt_progress_bar(0, 3); }
            // Add the uuid to the queue in sgstore at the specified level
            sgstore['queue'][qlvl].push(uuid);
            // If newline is greater than 0, set newLineCheck to newline
            if ((newline || 0) > 0) {
                newLineCheck = newline;
            }
            // Call the lt_timer function with 0 as the argument to resume if idle
            lt_timer(0);
        }
    }

    // This function adds a node to the delayed processing queue
    /**
     * Stores the current time plus the delay time, the node, the level, the newline value, and the function in sgstore with the uuid as the key.
     * @param {string} uuid - The unique identifier for the delayed queue.
     * @param {Node} mynode - The node to be stored in the delayed queue.
     * @param {number} qlvl - The level of the delayed queue.
     * @param {boolean} newline - The newline value for the delayed queue.
     * @param {Function} func - The function to be stored in the delayed queue.
     */
    function lt_delayed_queue(uuid, mynode, qlvl, newline, delaytimer, func) {
        // Store the current time plus the delay time, the node, the level, the newline value, and the function in sgstore with the uuid as the key
        sgstore['dqueue'][uuid] = [((new Date).getTime() + delaytimer), mynode, qlvl, newline, func];
    }

    // This function adds a node to the inactive processing queue and will be process only after a period of time after when the user is inactive
    /**
     * Resets the inactivity timer and adds the specified UUID to the inactive queue if it is not already present.
     * @param {string} uuid - The UUID to add to the inactive queue.
     * @param {Node} mynode - The node associated with the UUID.
     * @param {number} qlvl - The level of the queue.
     * @param {boolean} newline - The newline value.
     * @param {number} delaytimer - The delay time.
     * @param {Function} func - The function associated with the UUID.
     */
    function lt_inactive_queue(uuid, mynode, qlvl, newline, delaytimer, func) {
        // Reset the inactivity timer
        lt_inactive = 0;
        // If the uuid is not already in the inactive queue
        if (sgstore['iaqueue'][uuid] == undefined) {
            // Store the delay time, the node, the level, the newline value, and the function in sgstore with the uuid as the key
            sgstore['iaqueue'][uuid] = [delaytimer, mynode, qlvl, newline, func];
        }
    }


    // Timer

    /**
     * Timer function for LanguageTool.
     * @param {number} mode - The mode of the timer.
     */
    function lt_timer(mode) {
        //lt_debug("mode="+mode);
        if (mode == 1 && lastActive < (30 * 1000) && timerSet == 0) {
            timerSet = 1;
            setTimeout(lt_timer_func, 100);
        } else if (mode == 0 && lastActive >= (30 * 1000) && timerSet == 0) {
            timerSet = 1;
            lastActive = 0;
            setTimeout(lt_timer_func, 100);
        } else if (mode == 0) {

        }

    }

    /**
     * Timer function for LanguageTool.
     * Executes the queued language checks and sends the text to the server for processing.
     */
    var lt_timer_func = function () {

        // If the timer is off, return immediately
        if (timerOff == 1) {
            return;
        }

        // Increment inactive, timerRunner, and lastActive by 100
        updateTimers();

        // Run all functions in the 'run' array of sgstore and then clear the array
        runScheduledFunctions();

        // If newLineCheck is 1 and the time since the last run is less than the current time, reset timerRunner
        if (newLineCheck == 1 && (lastRun + lt_remoteTimer) < (new Date).getTime()) {
            lt_debug('INFO|LAST RUN WITHIN TIMER', 4);
            timerRunner = lt_remoteTimer;
        }

        // If timerRunner is greater than or equal to lt_remoteTimer and the number of instances is less than the maximum, proceed
        if (timerRunner >= lt_remoteTimer && Object.keys(listInstances).length < lt_maxInstances) {

            // For each item in the 'iaqueue' array of sgstore, if lt_inactive is greater than the first element of the item, delete the item and queue it
            $.each(sgstore['iaqueue'], function (key, val) {
                if (lt_inactive > val[0]) {
                    delete (sgstore['iaqueue'][key]);
                    lt_queue(key, val[1], val[2], val[3]);
                    if (val[4] != undefined) {
                        val[4].call();
                    }
                }
            });

            // Similar to the above, but for the 'dqueue' array and the condition is if the first element of the item is less than the current time
            $.each(sgstore['dqueue'], function (key, val) {
                if (val[0] < (new Date).getTime()) {
                    delete (sgstore['dqueue'][key]);
                    lt_queue(key, val[1], val[2], val[3]);
                    if (val[4] != undefined) {
                        val[4].call();
                    }
                }
            });

            // Reset newLineCheck and timerRunner
            newLineCheck = 0;
            timerRunner = 0;

            // Initialize data object with text and language
            var data = {
                text: "",
                language: lt_setLanguage
            };

            // If lt_postdata is defined in lt_set, add its key-value pairs to data
            if (lt_set['lt_postdata'] != undefined) {
                $.each(lt_set['lt_postdata'], function (key, val) {
                    data[key] = val;
                });
            }

            // If 'disabledRules' in data is undefined or empty
            if ((data['disabledRules'] || '') == '') {
                // Set 'disabledRules' in data to the keys of 'rule' in 'ignore' of sgstore, joined by commas
                data['disabledRules'] = '' + Object.keys(sgstore['ignore']['rule']).join(',');
            }
            // If 'disabledRules' in data is defined and 'rule' in 'ignore' of sgstore has keys
            else if (Object.keys(sgstore['ignore']['rule']).length > 0) {
                // Append the keys of 'rule' in 'ignore' of sgstore, joined by commas, to 'disabledRules' in data
                data['disabledRules'] += ',' + Object.keys(sgstore['ignore']['rule']).join(',');
            }

            // If 'disabledCategories' in data is undefined or empty
            if ((data['disabledCategories'] || '') == '') {
                // Set 'disabledCategories' in data to the keys of 'categories' in 'ignore' of sgstore, joined by commas
                data['disabledCategories'] = '' + Object.keys(sgstore['ignore']['categories']).join(',');
            }
            // If 'disabledCategories' in data is defined and 'categories' in 'ignore' of sgstore has keys
            else if (Object.keys(sgstore['ignore']['categories']).length > 0) {
                // Append the keys of 'categories' in 'ignore' of sgstore, joined by commas, to 'disabledCategories' in data
                data['disabledCategories'] += ',' + Object.keys(sgstore['ignore']['categories']).join(',');
            }

            // If 'disabledRules' in data is empty, delete it
            if (data['disabledRules'] == '') {
                delete (data['disabledRules']);
            }
            // If 'disabledCategories' in data is empty, delete it
            if (data['disabledCategories'] == '') {
                delete (data['disabledCategories']);
            }

            // Initialize tsize to 0
            var tsize = 0;
            // Initialize tdata to an object with 'text' set to an empty string and 'size' set to 0
            var tdata = { text: '', size: 0 };



            // Set tcont to 1
            var tcont = 1;

            // Loop over the length of the 'queue' array in sgstore
            ({ tcont, tsize } = processQueueItems(tcont, tdata, tsize));

            // Call lt_debug with the 'queue' property of sgstore and 5 as arguments
            //lt_debug(sgstore['queue'], 5);

            // Set last_winPos to winPos
            last_winPos = winPos;




            lt_debug("INFO|SENT-TEXT=" + data['text'], 4);

            // Check if 'text' in tdata is not empty
            if (tdata['text'] != '') {

                // Generate a unique identifier and store it in ikey
                var ikey = getUUID();
                // Store tdata in listInstances with ikey as the key
                listInstances[ikey] = tdata;

                // Set 'text' in data to 'text' in listInstances with ikey as the key
                data['text'] = listInstances[ikey]['text'];
                // Store the current time in lastRun
                lastRun = (new Date).getTime();
                // Make an AJAX POST request
                makeAjaxRequest(data, tsize, ikey);
            }


        }
        timerSet = 0;
        lt_timer(1);

    };




    var lut = []; for (var i = 0; i < 256; i++) { lut[i] = (i < 16 ? '0' : '') + (i).toString(16); }
    /**
     * Processes the queue items in sgstore.
     * 
     * @param {number} tcont - The value of tcont.
     * @param {object} tdata - The value of tdata.
     * @param {number} tsize - The value of tsize.
     * @returns {object} - An object containing tcont and tsize.
     */
    function processQueueItems(tcont, tdata, tsize) {
        for (var i = 0; i < sgstore['queue'].length; i++) {

            // If viewport_process of sgstore is 'only' or 'nearby' and i is 1 and last_winPos is equal to winPos, skip this iteration
            if ((sgstore.viewport_process == 'only' || sgstore.viewport_process == 'nearby') && i == 1 && last_winPos == winPos) {
                continue;
            }

            // Initialize tarray to an empty array and tlen to the length of the i-th element of the 'queue' array in sgstore
            var tarray = [];
            var tlen = sgstore['queue'][i].length;

            // Loop over tlen
            for (var i2 = 0; i2 < tlen; i2++) {

                // Set key to the i2-th element of the i-th element of the 'queue' array in sgstore
                var key = sgstore['queue'][i][i2];

                // If the 'lock' property of sgstore at key is not 1
                if (sgstore['lock'][key] != 1) {

                    // If key is in sgcheck
                    if (key in sgcheck) {

                        // If viewport_process of sgstore is 'only' and the length of sgcheck at key is greater than or equal to 2 and lt_onscreen of the 'obj' property of sgstore at key is not 1
                        // Or if viewport_process of sgstore is 'nearby' and the length of sgcheck at key is greater than or equal to 2 and lt_onscreen of the 'obj' property of sgstore at key is 0
                        // Then set lastActive to 0, push key to tarray, and skip this iteration
                        if ((sgstore.viewport_process == 'only' && sgcheck[key].length >= 2 && lt_onscreen($(sgstore['obj'][key])) != 1) ||
                            (sgstore.viewport_process == 'nearby' && sgcheck[key].length >= 2 && lt_onscreen($(sgstore['obj'][key])) == 0)) {
                            lastActive = 0;
                            tarray.push(key);
                            continue;
                        }

                        // Set val to sgcheck at key
                        var val = sgcheck[key];

                        // Append key and two newlines to val and store it in tval
                        var tval = val + "\t(" + key + ")\n\n";

                        // If tcont is 1
                        if (tcont == 1) {

                            // Remove all whitespace from val and store it in sval
                            var sval = val.replace(/\s/g, '');

                            // If the length of sval is greater than or equal to 2 and val is not equal to the 'text' property of sgstore at key and the 'UUID' data of the 'obj' property of sgstore at key is equal to key
                            if (sval.length >= 2 && $(sgstore['obj'][key]).data('UUID') == key) {

                                // If the 'text' property of tdata is empty or the sum of the lengths of the 'text' property of tdata and tval is less than lt_sizeOfInstances
                                if (tdata['text'] == '' || (tdata['text'].length + tval.length) < lt_sizeOfInstances) {

                                    // Append tval to the 'text' property of tdata and increment tsize
                                    tdata['text'] = tdata['text'] + tval;
                                    tsize++;

                                } else {

                                    // Set newLineCheck to 1 and tcont to 0
                                    newLineCheck = 1;
                                    tcont = 0;
                                }
                            } else {

                                // Delete sgcheck at key and call lt_progress_bar with 3 if viewport_process of sgstore is 'disabled', otherwise with 0
                                delete (sgcheck[key]);
                                lt_progress_bar(sgstore.viewport_process == 'disabled' ? 3 : 0);
                                continue;
                            }
                        }

                        // If tcont is 1
                        if (tcont == 1) {

                            // Set the 'text' property of sgstore at key to sgcheck at key and delete sgcheck at key
                            sgstore['text'][key] = '' + sgcheck[key];
                            delete (sgcheck[key]);

                            // Call lt_progress_bar with 1 if viewport_process of sgstore is 'disabled', otherwise with 0 and 2
                            if (sgstore.viewport_process == 'disabled') { lt_progress_bar(1); } else { lt_progress_bar(0, 2); }
                            continue;
                        }

                        // Set lastActive to 0
                        lastActive = 0;

                    } else {

                        // Call lt_progress_bar with 3 if viewport_process of sgstore is 'disabled', otherwise with 0
                        lt_progress_bar(sgstore.viewport_process == 'disabled' ? 3 : 0);
                        continue;
                    }

                }

                // Push key to tarray
                tarray.push(key);
            }

            // Set the i-th element of the 'queue' array in sgstore to tarray
            sgstore['queue'][i] = tarray;
        }
        return { tcont, tsize };
    }

    /**
     * Runs the scheduled functions stored in the sgstore['run'] array.
     */
    function runScheduledFunctions() {
        $.each(sgstore['run'], function (i, val) {
            sgstore['run'][i].func();
        });
        sgstore['run'] = [];
    }

    function updateTimers() {
        lt_inactive += 100;
        timerRunner += 100;
        lastActive += 100;
    }

    /**
     * Makes an AJAX request to the LanguageTool URL with the provided data.
     * @param {Object} data - The data to be sent in the request.
     * @param {number} tsize - The size of the text.
     * @param {string} ikey - The index key.
     */
    function makeAjaxRequest(data, tsize, ikey) {
        console.log('Sending AJAX request with data:', data);
        $.ajax({
            type: "POST",
            url: lt_remoteUrl,
            data: data,
            indexValue: { text: data['text'], tsize: tsize, ikey: ikey },
            //contentType: "multipart/form-data"
            dataType: "json",
            success: function (data) {
                // On success, push a new object to the 'run' array of sgstore
                console.log('Success call processing:', data);
                processSuccessRequest.call(this, data);
            },
            failure: function (errMsg) {

                delete (listInstances[this.indexValue.ikey]);

                lt_debug('ERROR|' + errMsg, 2);
                console.log('Error Sending Request')
            }
        });
    }

    /**
     * Process the success response of a the LT server.
     * 
     * @param {Object} data - The response data.
     */
    function processSuccessRequest(data) {
        // Update the progress bar based on the size of the text checked
        lt_progress_bar(this.indexValue.tsize);

        // Store the response data (json) and the original text (mytext) in local variables for further processing
        var json = data;
        var mytext = this.indexValue.text;

        // Initialize uuidcount for counting UUID occurrences, and bm (bookmark) is set using a bookmark function call
        var uuidcount = {};
        var bm = sgfunc['bookmark'].call();

        // Use a regular expression to find all UUIDs in the text to remove existing highlight
        mytext.replace(/\t\(([a-f0-9-]{36})\)\n\n/g, function (pmatch, p1) {
            var tempid = p1;

            // Retrieve the corresponding HTML content from sgstore['obj'][tempid], clear any existing highlights, and then update the HTML back to the node
            var temphtml = lt_clearHighlighter(lt_text($(sgstore['obj'][tempid]).html()));
            $(sgstore['obj'][tempid]).html(temphtml);

            return pmatch;
        });

        // Initialize fmatch and locklist to track which nodes have been processed and which nodes need to be locked during processing
        var fmatch = {};
        var locklist = {};

        // Store the length of 'matches' in json in tlen
        var tlen = json['matches'].length;
        // Process each match in the response from the LanguageTool server
        for (var i = 0; i < tlen; i++) {
            var item = json['matches'][i];
            var hclass = lt_setHighlight['other'];
            if (lt_setHighlight[item['rule']['issueType']] != undefined) {
                hclass = lt_setHighlight[item['rule']['issueType']];
            }
            var tempstr = mytext.substr(item['offset']);
            var uuid, templen, tempword;
            tempword = tempstr.substr(0, item['length']);
            tempstr.replace(/(?:^|\n)(.*?\t)\(([a-f0-9-]{36})\)\n/, function (pmatch, p1, p2) { uuid = p2; return pmatch; });
            mytext.replace(new RegExp(".*\\([a-f0-9-]{36}\\)(?:\n\n)([^\\t]+?\\t\\(" + uuid + "\\))\n\n"), function (pmatch, p1) { templen = mytext.indexOf(p1); return pmatch; });
            if (templen == undefined) {
                templen = 0;
            }
            lt_debug('INFO|WORD=' + tempword + '|OFFSET=' + item['offset'] + '|LEN=' + item['length'] + '|ADJLEN=' + templen, 4);
            if (uuid != undefined && sgstore['ignore']['all'][tempword] == undefined && (sgstore['ignore']['once'][uuid] == undefined || sgstore['ignore']['once'][uuid][tempword] == undefined)) {
                item['offset'] -= templen;
                lt_debug("TRACE|OFFSET=" + item['offset'] + '=' + templen, 6);
                if (fmatch[uuid] == undefined) {
                    sgstore['lt'][uuid] = {};
                    fmatch[uuid] = 1;
                }
                sgstore['lt'][uuid][i] = item;
                sgstore['lt'][uuid][i]['word'] = tempword;
                lt_applyHighlighter(sgstore['obj'][uuid], i, tempword, item['rule']['id'], hclass, item['offset'], item['offset'] + item['length'], item['replacements'], item['message'], item['shortMessage']);
                locklist[uuid] = 1;
            }
        }

        // Iterate over locklist to lock all nodes that have been processed
        $.each(locklist, function (key, val) {
            lt_lock(0, key);
        });

        // Restore the bookmark to its original state, delete the processed instance from listInstances, and update the progress bar
        sgfunc['bookmark'].call(this, bm);
        delete (listInstances[this.indexValue.ikey]);
        lt_progress_bar(this.indexValue.tsize);
    }


    function getUUID() {
        var d0 = Math.random() * 0xffffffff | 0;
        var d1 = Math.random() * 0xffffffff | 0;
        var d2 = Math.random() * 0xffffffff | 0;
        var d3 = Math.random() * 0xffffffff | 0;
        return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +
            lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +
            lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +
            lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
    }

    function setUUID(mynode) {

        if ((lt_ignoreBlockTags[mynode.nodeName] || 0) == 0 && (lt_ignoreSelector == undefined || (lt_ignoreSelector != undefined && !($(mynode).is(lt_ignoreSelector))))) {

            var uuid = getUUID();
            $(mynode).data('UUID', uuid);

            return uuid;
        }

    }

    function insertAt(mystr, CharToInsert, Position) {
        return mystr.slice(0, Position) + CharToInsert + mystr.slice(Position)
    }


    // Backend Functions


    /**
     * Clears the highlighter and suggestions panel in the content.
     * 
     * @param {string} content - The content to remove the highlighter from.
     * @returns {string} - The modified content with the highlighter removed.
     */
    function lt_clearHighlighter(content) {
        // Replace all occurrences of the regex pattern in content with the first capturing group and store the result in temphtml
        var temphtml = content.replace(/<span class="lt-highlight(?:-remove|)[\w \-]+?" data-hid="[0-9]+" data-word="[a-zA-Z0-9\/=+]+" data-rule="[a-zA-Z0-9_]+">(.*?)<\/span>/g, function (match, p1) { return p1; });

        // Log debug information
        lt_debug('TRACE|CLEAR=' + temphtml, 6);

        // Get the element with id 'suggestions-panel' and store it in suggestionsList
        var suggestionsList = document.getElementById('suggestions-panel');

        // Clear the inner HTML of suggestionsList
        suggestionsList.innerHTML = '';

        // Return temphtml
        return temphtml;
    }

    /**
     * Applies highlighting to a given object based on the provided parameters.
     *
     * @param {Object} myobj - The object to apply highlighting to.
     * @param {string} myid - The ID of the highlighting.
     * @param {string} myword - The word to be highlighted.
     * @param {string} myrule - The rule associated with the highlighting.
     * @param {string} myclass - The CSS class for the highlighting.
     * @param {number} mystart - The starting index of the highlighting.
     * @param {number} myend - The ending index of the highlighting.
     * @param {Array} suggestions - An array of suggestions for the highlighted word.
     * @param {string} message - The detailed message associated with the highlighting.
     * @param {string} shortMessage - The short message associated with the highlighting.
     */
    function lt_applyHighlighter(myobj, myid, myword, myrule, myclass, mystart, myend, suggestions, message, shortMessage) {
        var alist = {};
        console.log("Parameters passed into lt_applyHighlighter: ", { myobj, myid, myword, myrule, myclass, mystart, myend, suggestions, message, shortMessage });

        // Extract the text and HTML from myobj
        var mytext = lt_text($(myobj).text());
        var myhtml = lt_text($(myobj).html());

        // Debug log
        lt_debug('TRACE|HIGHLIGHT-HTML-PRE=' + myobj + '=' + myhtml + '=', 6);

        // Pattern to match HTML tags and HTML entities
        var patt = /(\<.*?\>)|&(?:nbsp|amp|quot|copy|reg|[gl]t|\#[0-9a-f]+);/ig;

        // Adjust mystart and myend to account for HTML tags and entities
        while (match = patt.exec(myhtml)) {
            var topt;

            if (match[0].substr(0, 3) == '<br') {
                topt = patt.lastIndex - match.index - 1;
            } else if (match[0].substr(0, 1) == '<') {
                topt = patt.lastIndex - match.index;
            } else {
                topt = patt.lastIndex - match.index - 1;
            }

            if (mystart >= match.index) {
                mystart = mystart + topt;
            }

            if (myend > match.index) {
                myend = myend + topt;
            }
        }

        // Create the highlight span
        var myspan = '<span class="lt-highlight ' + myclass + '" data-hid="' + myid + '" data-word="' + window.btoa(encodeURIComponent(myword)) + '" data-rule="' + myrule + '">';

        // Insert the highlight span into myhtml
        myhtml = insertAt(myhtml, myspan, mystart);
        myhtml = insertAt(myhtml, '</span>', myend + myspan.length);

        // Remove duplicate closing tags
        var ddup = new RegExp('</(EM|STRONG|SUP|SUB)><\\1>', 'i');
        myhtml = myhtml.replace(ddup, '');

        // Debug log
        lt_debug('TRACE|HIGHLIGHT-HTML-POST=' + myhtml, 6);

        // Update the HTML of myobj
        $(myobj).html(myhtml);

        // Update the suggestions panel
        var suggestionsPanel = document.getElementById('suggestions-panel');

        // Construct the HTML for the suggestions
        var suggestionHTML = `
        <div class="upgrade_vocab ${myclass}" data-hid="${myid}" data-word="${window.btoa(encodeURIComponent(myword))}" data-rule="${myrule}">
            <span class="original-vocab">${myword}</span>
            <span class="arrow">-></span>`;

        // Add each suggestion to the HTML
        suggestions.forEach(function (suggestion) {
            suggestionHTML += `<span class="improved-vocab">${suggestion.value}</span>`;
        });

        // Complete the HTML for the suggestions
        suggestionHTML += `
            <span class="short-explanation"> Â· ${shortMessage || message || ''}</span>
            <br>
        <span class="explanation">${message || shortMessage || ''}</span>
        </div>`;

        // Add the suggestions to the suggestions panel
        suggestionsPanel.insertAdjacentHTML('beforeend', suggestionHTML);
        // Add event listener to the newly created div
        var $newDiv = $(".upgrade_vocab[data-hid='" + myid + "']");
        //console.log("Before calling hideAndShowElements");
        hideAndShowElements($newDiv);
        //console.log("After calling hideAndShowElements");

        //console.log("Before calling addClickEventListenerToDiv");
        addClickEventListenerToDiv($newDiv, myword);
        console.log("Finish adding highlight");
    }



    /**
     * Determines if the given element is on the screen or not.
     * @param {jQuery} obj - The jQuery object representing the element.
     * @returns {number} - Returns 1 if the element is on the screen, 2 if it is partially on the screen, and 0 if it is not on the screen.
     */
    function lt_onscreen(obj) {
        // Define a viewport object with properties for the top and bottom of the viewport
        var viewport = {
            top: win.scrollTop(),
        };
        // Calculate the bottom of the viewport
        viewport.bottom = viewport.top + win.height();

        // Get the offset of the object and store it in bounds
        var bounds = obj.offset();

        // Calculate the bottom of the object
        bounds.bottom = bounds.top + obj.outerHeight();

        // Define an offset value
        var offset = 200 + win.height();

        // Check if the object is within the viewport
        if (!(viewport.bottom < bounds.top || viewport.top > bounds.bottom)) {
            // If the object is within the viewport, return 1
            return 1;
        }
        // Check if the object is within the offset
        else if (!(viewport.bottom + offset < bounds.top || viewport.top - offset > bounds.bottom)) {
            // If the object is within the offset, return 2
            return 2;
        }

        // If the object is not within the viewport or the offset, return 0
        return 0;
    }

    function lt_lock(mode, uuid) {


    }


    /**
     * Decodes and returns the given string after removing any UTF-8 byte order mark (BOM) characters.
     * @param {string} str - The string to be decoded and processed.
     * @returns {string} - The decoded string without any BOM characters.
     */
    function lt_text(str) {


        str = encodeURIComponent(str);
        var reg = /\%EF\%BB\%BF/g;

        return decodeURIComponent(str.replace(reg, ''));

    }

    /**
     * Converts the HTML content of a given node into plain text and encoded HTML.
     * 
     * @param {Node} mynode - The node containing the HTML content.
     * @returns {Object} - An object with the encoded HTML and plain text content.
     */
    function lt_textHTML(mynode) {
        var tnode = $('<div />');

        var thtml = ($(mynode).prop('tagName') != undefined ? $(mynode).html() : '').replace(/<br/gi, '\n<br');
        //thtml = ($(mynode).html()||'').replace(/&nbsp\;/gi,' ');
        $(tnode).html(thtml);

        var ttext = encodeURIComponent($(tnode).text());
        thtml = encodeURIComponent(thtml);
        var reg = /\%EF\%BB\%BF/g;

        return { html: decodeURIComponent(thtml.replace(reg, '')), text: decodeURIComponent(ttext.replace(reg, '')) };


    }

    function lt_debug(content, level) {
        if (lt_debugLevel >= (level || 1)) {
            console.log(content);
        }
    }

    /**
     * Finds the parent node of a given node.
     * 
     * @param {Node} mynode - The node for which to find the parent node.
     * @returns {Node} - The parent node of the given node.
     */
    function lt_find_parent_node(mynode) {


        if (mynode.nodeName == 'HTML' || mynode.nodeName == 'BODY') {
            return {};
        }

        var mypnode = mynode;

        var nodeExc = { "TABLE": 1, "TBODY": 1, "TR": 1, "TH": 1 };

        var pfind = 0;
        while (pfind != 1) {


            //if ( mynode.nodeName == 'STRONG' || mynode.nodeName == 'EM' || (mynode.nodeName == 'SPAN' && /hl[rgnybop][0-9]/.test($(mynode).attr('class')) == false ) ) {
            if ($(mypnode).data('UUID') == undefined) {


                if ($(mypnode).css('display') != 'inline' && (lt_ignoreBlockTags[mynode.nodeName] || 0) == 0 && (nodeExc[mynode.nodeName] || 0) == 0 && (lt_ignoreSelector == undefined || (lt_ignoreSelector != undefined && !($(mynode).is(lt_ignoreSelector))))) {

                    var uuid = setUUID(mypnode);
                    return mypnode;
                } else if (mypnode.parentNode.nodeName == 'BODY') {
                    var uuid = setUUID(mypnode);
                    return mypnode;


                } else {
                    mypnode = mypnode.parentNode
                }


            } else {
                pfind = 1;
            }
        }
        return mypnode;
    }




    /**
     * Calculates the caret offset within an element.
     * 
     * @param {HTMLElement} element - The element to calculate the caret offset for.
     * @returns {number} The caret offset.
     */
    function getCaretOffset(element) {
        var caretOffset = 0;
        var doc = element.ownerDocument || element.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (typeof win.getSelection != "undefined") {
            sel = win.getSelection();
            if (sel.rangeCount > 0) {
                var range = win.getSelection().getRangeAt(0);
                var preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                caretOffset = preCaretRange.toString().length;
            }
        } else if ((sel = doc.selection) && sel.type != "Control") {
            var textRange = sel.createRange();
            var preCaretTextRange = doc.body.createTextRange();
            preCaretTextRange.moveToElementText(element);
            preCaretTextRange.setEndPoint("EndToEnd", textRange);
            caretOffset = preCaretTextRange.text.length;
        }
        return caretOffset;
    }



    /**
     * Processes new content for LanguageTool (the whole doc).
     *
     * @param {Event} e - The event object.
     */
    function lt_new_content_process(e) {
        // Get the body element and store it in pnode
        var pnode = sgfunc['body'].call();

        // Log the HTML of pnode for debugging
        lt_debug('TRACE|SETBODY=' + $(pnode).html(), 6);

        // Iterate over each child of pnode
        $(pnode).find("*").each(function () {
            // Store the current child in mynode
            var mynode = this;

            // Define an object with keys for certain node names
            var nodeExc = { "TABLE": 1, "TBODY": 1, "TR": 1, "TH": 1 };

            // Check if mynode is an inline element, is in lt_ignoreBlockTags, is in nodeExc, or matches lt_ignoreSelector
            if ($(mynode).css('display') == 'inline' || (lt_ignoreBlockTags[mynode.nodeName] || 0) == 1 || nodeExc[mynode.nodeName] == 1 || (lt_ignoreSelector != undefined && $(mynode).is(lt_ignoreSelector))) {
                // If any of the conditions are met, skip this node
            } else {
                // Initialize tcontinue to 0
                var tcontinue = 0;

                // Iterate over each child node of mynode
                $.each(mynode.childNodes, function (i, cnode) {
                    // If cnode is a text node and its value is not '\n', or if cnode is an inline element, set tcontinue to 1
                    if (cnode.nodeType == 3 && cnode.nodeValue != '\n') {
                        tcontinue = 1;
                    } else if (cnode.nodeType == 1 && $(cnode).css('display') == 'inline') {
                        tcontinue = 1;
                    }
                });

                // If tcontinue is 1
                if (tcontinue == 1) {
                    // Get or set the UUID of mynode
                    var uuid = $(mynode).data('UUID');
                    if (uuid == undefined) {
                        uuid = setUUID(mynode);
                    }

                    // Log the node name and UUID of mynode
                    lt_debug("INFO|SET CONTENT=" + mynode.nodeName + "=" + uuid, 4);

                    // Add mynode to the queue
                    lt_queue(uuid, mynode, 1, 0);
                }
            }
        });

        // Set last_winPos to -1
        last_winPos = -1;
    }

    // Progress bar

    /**
     * Updates the progress bar for LanguageTool.
     * @param {number} prog - The progress value to be added.
     * @param {number} [maxprog] - The maximum progress value.
     */
    function lt_progress_bar(prog, maxprog) {
        // If maxprog is defined, increment the second element of sgstore['progress'] by maxprog
        if (maxprog != undefined) {
            sgstore['progress'][1] += maxprog;
        }

        // If prog is greater than 0
        if (prog > 0) {
            // Increment the first element of sgstore['progress'] by prog
            sgstore['progress'][0] += prog;

            // If the first element of sgstore['progress'] is greater than or equal to one twentieth of the second element times the third element plus one
            if (sgstore['progress'][0] >= (sgstore['progress'][1] / 20) * (sgstore['progress'][2] + 1)) {
                // If the first and second elements of sgstore['progress'] are equal, reset sgstore['progress'] to [0, 0, 0, 0]
                if (sgstore['progress'][0] == sgstore['progress'][1]) {
                    sgstore['progress'] = [0, 0, 0, 0];
                } else {
                    // Otherwise, increment the third element of sgstore['progress']
                    sgstore['progress'][2]++;
                }

                // If lt_showProgressBar is true
                if (lt_showProgressBar == true) {
                    // Get the progress container and store it in progress_status
                    var progress_status = sgfunc['progress_container'].call();

                    // Find the progress bar within progress_status and store it in progress_bar
                    var progress_bar = $(progress_status).find('progress');

                    // Set the max attribute of progress_bar to the second element of sgstore['progress']
                    $(progress_bar).attr('max', sgstore['progress'][1]);

                    // Set the value of progress_bar to the first element of sgstore['progress']
                    $(progress_bar).val(sgstore['progress'][0]);

                    // Get the next sibling of progress_bar and store it in progress_issues
                    var progress_issues = progress_bar.next();

                    // Set the HTML of progress_issues to the number of .lt-highlight elements in the body plus ' Issue(s)'
                    $(progress_issues).html($(sgfunc['body'].call()).find('.lt-highlight').length + (sgstore.viewport_process == 'disabled' ? '' : '+') + ' Issue(s)');
                }

                // Log the first and second elements of sgstore['progress']
                lt_debug('INFO|PROGRES=' + sgstore['progress'][0] + '/' + sgstore['progress'][1], 4);
            }
        }
    }


    // Suggestion Dialog

    /**
     * Finds the next issue and displays it along with suggestions.
     * @param {boolean} firstOpen - Indicates if it is the first time the function is called.
     * @returns {boolean} - Returns false if the issue should be skipped, otherwise returns true.
     */
    function lt_nextIssue(firstOpen) {
        // Find the first .lt-highlight element in the body that does not have the .skip-dialog-highlight class and store it in mynode
        var mynode = $(sgfunc['body'].call()).find('.lt-highlight').not('.skip-dialog-highlight').get(0);

        // If mynode is undefined
        if (mynode == undefined) {
            // Empty the #lt_issueSuggestions element and display an alert saying 'Done!'
            $('#lt_issueSuggestions').empty();
            sgfunc['alert'].call(this, 'Done!');
        } else {
            // Add the .dialog-highlight class to mynode
            $(mynode).addClass('dialog-highlight');

            // Find the parent node of mynode and store it in mypnode
            var mypnode = lt_find_parent_node(mynode);
            // Get the UUID and hid data attributes of mypnode and mynode respectively and store them in uuid and hid
            var uuid = $(mypnode).data('UUID');
            var hid = $(mynode).data('hid');

            // If firstOpen is not defined or is 0
            if ((firstOpen || 0) == 0) {
                // If there is an unchecked #lt-filter-check- element with the issueType of the rule in sgstore['lt'][uuid][hid]
                if ($('#lt-filter-check-' + sgstore['lt'][uuid][hid]['rule']['issueType'] + '[aria-checked="false"]').length == 1) {
                    // Remove the .dialog-highlight class from mynode, add the .skip-dialog-highlight class, call lt_nextIssue, and return false
                    $(mynode).removeClass('dialog-highlight').addClass('skip-dialog-highlight');
                    lt_nextIssue();
                    return false;
                }
            }

            // Empty the #lt_issueSuggestions element
            $('#lt_issueSuggestions').empty();

            // Set the text of #lt_issueMessage to the issueType and message of the rule in sgstore['lt'][uuid][hid]
            $('#lt_issueMessage').text('[' + sgstore['lt'][uuid][hid]['rule']['issueType'].charAt(0).toUpperCase() + sgstore['lt'][uuid][hid]['rule']['issueType'].slice(1) + '] ' + sgstore['lt'][uuid][hid]['message']);

            // Iterate over each replacement in sgstore['lt'][uuid][hid]['replacements']
            $.each(sgstore['lt'][uuid][hid]['replacements'], function (key, val) {
                // Set the ident-UUID and ident-HID data attributes of #lt_issueSuggestions to uuid and hid
                $('#lt_issueSuggestions').data('ident-UUID', uuid);
                $('#lt_issueSuggestions').data('ident-HID', hid);

                // If key is 0, set the value of #lt_issueChangeTo to the value of val
                if ((key == 0)) {
                    $('#lt_issueChangeTo').val(val['value']);
                }

                // Append an option element to #lt_issueSuggestions with the value and text set to the value of val, and selected set to true if key is 0
                $('#lt_issueSuggestions').append(
                    $('<option/>', {
                        value: val['value'],
                        text: val['value'],
                        selected: ((key == 0) ? true : false)
                    })
                );
            });

            // Set sgstore['contextmenu'] to mynode
            sgstore['contextmenu'] = mynode;

            // Scroll mynode into view and adjust the scroll position of the body by -50
            $(mynode).get(0).scrollIntoView();
            scrollAdjust($(mynode).closest('body').get(0), -50);
        }
    }

    function scrollAdjust(elem, num) {
        //  var re=/html$/i;
        //  while(!re.test(elem.tagName) && (1 > elem.scrollTop)) elem=elem.parentNode;

        if (0 < elem.scrollTop) elem.scrollTop += num;
    }

    // Context Menu

    /**
     * Opens the context menu for the given event.
     * 
     * @param {Event} e - The event object.
     * @returns {number} - Returns 1 if the context menu was opened, otherwise 0.
     */
    function lt_openContextMenu(e) {
        // Identify the node where the event occurred
        var mynode = e.target;

        // Calculate the parent node of the clicked node
        var mypnode = mynode.parentNode;

        var nfind = 0;

        // Find the right node to apply the context menu
        var mypnode = lt_find_parent_node(mynode);

        // Specify node types to be considered
        var nodeExc = { "STRONG": 1, "EM": 1, "SUP": 1, "SUB": 1, "I": 1, "B": 1, "U": 1 };

        // Loop to check if the current node is one of the specified node types
        while (nfind != 1) {
            if (nodeExc[mynode.nodeName] == 1 || (mynode.nodeName == 'SPAN' && $(mynode).hasClass('lt-highlight') == false && $(mynode).hasClass('lt-highlight-remove') == false)) {
                // If it is, move up to the parent node
                mynode = mynode.parentNode;
            } else {
                nfind = 1;
            }
        }


        lt_debug('TRACE|CONTEXT-MENU=' + mynode.nodeName, 6);



        if ($(mynode).hasClass('lt-highlight') == true) {
            sgstore['contextmenu'] = mynode;

            var uuid = $(mypnode).data('UUID');
            sgstore['lock'][uuid] = 1;

            var hid = $(mynode).data('hid');

            lt_debug('INFO|CONTEXT-MENU-NEW=' + mynode.nodeName + '|' + uuid + '=' + hid + '|', 4);
            e.preventDefault();

            $("#context-menu-ul").empty();



            $("#context-menu-ul").append(
                $('<li/>', {
                    "html": ((sgstore['lt'][uuid][hid]['shortMessage'] == '' || lt_fullMessage == true) ? sgstore['lt'][uuid][hid]['message'] : sgstore['lt'][uuid][hid]['shortMessage']),
                    "class": "context-menu-header"
                })
            );

            var countSuggestions = 0;
            $.each(sgstore['lt'][uuid][hid]['replacements'], function (key, val) {

                if (countSuggestions < 10) {
                    $("#context-menu-ul").append(
                        $('<li/>', {
                            "html": val['value'],
                            "class": "context-menu-item",
                            "data-ident-uuid": uuid,
                            "data-ident-hid": hid,
                            "data-ident-value": val['value']
                        })
                    );
                } else {

                    if (countSuggestions == 10) {
                        $("#context-menu-ul").append(
                            $('<li/>', {
                                "html": "More...<ul id='context-submenu-ul'></ul>",
                                "id": "context-menu-item-list",
                                "data-ident-uuid": uuid,
                                "data-ident-hid": hid,
                                "data-ident-value": val['value']
                            })
                        );
                    }
                    $("#context-submenu-ul").append(
                        $('<li/>', {
                            "html": val['value'],
                            "class": "context-menu-item",
                            "data-ident-uuid": uuid,
                            "data-ident-hid": hid,
                            "data-ident-value": val['value']
                        })
                    );
                }
                countSuggestions++;

            });


            $("#context-menu-ul").append(
                $('<li/>', {
                    "html": "-",
                    "class": "context-menu-break",

                })
            );

            $("#context-menu-ul").append(
                $('<li/>', {
                    "html": "Ignore Once",
                    "class": "context-menu-ignore",
                    "data-ident-uuid": uuid,
                    "data-ident-hid": hid,
                    "data-ident-value": "once"
                })
            );

            $("#context-menu-ul").append(
                $('<li/>', {
                    "html": "Ignore All",
                    "class": "context-menu-ignore",
                    "data-ident-uuid": uuid,
                    "data-ident-hid": hid,
                    "data-ident-value": "all"
                })
            );
            $("#context-menu-ul").append(
                $('<li/>', {
                    "html": "Ignore Rule",
                    "class": "context-menu-ignore",
                    "data-ident-uuid": uuid,
                    "data-ident-hid": hid,
                    "data-ident-value": "rule"
                })
            );


            var pageX = e.clientX + $(sgfunc['container'].call()).offset().left;
            var pageY = e.clientY + $(sgfunc['container'].call()).offset().top;

            var mwidth = $("#context-menu-nav").width();
            var mheight = $("#context-menu-nav").height();
            var screenWidth = $(window).width();
            var screenHeight = $(window).height();

            $("#context-submenu-ul").removeClass('context-submenu-ul-right');
            $("#context-submenu-ul").addClass('context-submenu-ul-left');
            $("#context-submenu-ul").removeClass('context-submenu-ul-bottom');
            $("#context-submenu-ul").addClass('context-submenu-ul-top');


            var scrTop = $(window).scrollTop();
            lt_debug("DEBUG|1=" + pageX + "=" + pageY + '=' + $(sgfunc['container'].call()).contents().scrollTop() + '=' + $(sgfunc['container'].call()).offset().top + '=' + e.clientY, 5);
            // right of window
            if (pageX + mwidth > screenWidth) {

                pageX = (pageX - mwidth);
                $("#context-submenu-ul").removeClass('context-submenu-ul-left');
                $("#context-submenu-ul").addClass('context-submenu-ul-right');
            }

            // bottom of window
            if (pageY + mheight > screenHeight + scrTop) {

                pageY = pageY - mheight;
                $("#context-submenu-ul").removeClass('context-submenu-ul-top');
                $("#context-submenu-ul").addClass('context-submenu-ul-bottom');
            }


            //lt_debug("DEBUG|2=" + pageX + "=" + pageY, 5);




            $("#context-menu-nav").finish().toggle(100).
                css({
                    top: pageY + "px",
                    left: pageX + "px"
                });

            return 1;
        }

        // Return 0 if the context menu was not opened
        return 0;
    }


    /**
     * Handles the click event of the context menu item.
     * 
     * @param {string} uuid - The UUID of the context menu item.
     * @param {string} hid - The HID of the context menu item.
     * @param {string} value - The value of the context menu item.
     * @param {number} mode - The mode of the context menu item.
     */
    function lt_contextMenuClick(uuid, hid, value, mode) {
        // Log the UUID, HID, and value
        //lt_debug('INFO|CONTEXT-ITEM=' + uuid + '=' + hid + '=' + value, 4);

        // Call the setundo function
        sgfunc['setundo'].call()

        // Set the lock for the UUID in sgstore to 0
        sgstore['lock'][uuid] = 0;

        // Get the context menu node from sgstore and store it in mynode
        var mynode = sgstore['contextmenu'];

        // If mynode is a span and has the lt-highlight class
        if (mynode.nodeName == 'SPAN' && $(mynode).hasClass('lt-highlight') == true) {
            // Define the function
            console.log("Running the function directly.");

            correctNode(mynode, value, mode);
        }
    }

    function correctNode(mynode, value, mode) {
        console.log("Running a function with the node, value, mode.");

        // Replace mynode with the value
        $(mynode).replaceWith(value);
        console.log("Replaced the node with the value: " + value);

        // If lt_showProgressBar is true
        if (lt_showProgressBar == true) {
            // Find the progress issues element and set its HTML to the number of lt-highlight elements in the body plus ' Issue(s)'
            var progress_issues = $(sgfunc['progress_container'].call()).find('progress').next();
            $(progress_issues).html($(sgfunc['body'].call()).find('.lt-highlight').length + ' Issue(s)');
        }

        // Add the the whole doc to the queue
        lt_new_content_process({});
        console.log("Added the whole document to the queue.");

        // If mode is 1, call lt_nextIssue
        if ((mode || 0) == 1) {
            lt_nextIssue();
        }
    }

    /**
     * Ignores a specific word, all occurrences of a word, or a rule in the context menu.
     * @param {string} uuid - The unique identifier of the word.
     * @param {string} hid - The unique identifier of the word's context.
     * @param {string} value - The value indicating the type of ignore action: 'once', 'all', or 'rule'.
     * @param {string} mode - The mode of the ignore action.
     */
    function lt_contextMenuIgnore(uuid, hid, value, mode) {





        //  var uuid = $(this).data("ident-uuid");
        //   var hid = $(this).data("ident-hid");
        sgstore['lock'][uuid] = 0;


        var mynode = sgstore['contextmenu'];

        if (mynode.nodeName == 'SPAN' && $(mynode).hasClass('lt-highlight') == true) {



            if (value == 'once') {
                if (sgstore['ignore']['once'][uuid] == undefined) {
                    sgstore['ignore']['once'][uuid] = {};
                }


                sgstore['ignore']['once'][uuid][sgstore['lt'][uuid][hid]['word']] = 1;

                var mynode = sgstore['contextmenu'];

                if (mynode.nodeName == 'SPAN' && $(mynode).hasClass('lt-highlight') == true) {


                    sgstore['run'].push({
                        node: mynode, mode: mode,
                        func: function () {
                            mynode = this.node;
                            $(mynode).replaceWith($(mynode).html());

                            // Add the the whole doc to the queue
                            lt_new_content_process({});
                            if ((this.mode || 0) == 1) {
                                lt_nextIssue();
                            }

                            //sgcheck[ uuid ]=lt_text($(mynode).parent().text());
                            //sgstore['html'][ uuid ]=lt_text($(mynode).parent().html());
                        }
                    });
                }


            } else if (value == 'all') {
                //lt_debug('INFO|IGNORE-ALL=' + sgstore['lt'][uuid][hid]['word'], 4);
                sgstore['ignore']['all'][sgstore['lt'][uuid][hid]['word']] = 1;

                sgstore['run'].push({
                    node: mynode, mode: mode,
                    func: function () {

                        $(sgfunc['body'].call()).find('span[data-word="' + window.btoa(encodeURIComponent(sgstore['lt'][uuid][hid]['word'])) + '"]').each(function () {
                            $(this).replaceWith($(this).html());

                        });

                        if ((this.mode || 0) == 1) {
                            lt_nextIssue();
                        }

                        lt_ignoreCallback.call(this, 'addWord', sgstore['lt'][uuid][hid]['rule']['id']);
                    }

                });


            } else if (value == 'rule') {

                sgfunc['confirm'].call(this, 'Are you sure you wish to ignore this rule going forward?', uuid, hid, function (e) {


                    sgstore['run'].push({
                        node: mynode, mode: mode,
                        func: function () {
                            sgstore['ignore']['rule'][sgstore['lt'][e.data.uuid][e.data.hid]['rule']['id']] = 1;

                            $(sgfunc['body'].call()).find('span[data-rule="' + sgstore['lt'][e.data.uuid][e.data.hid]['rule']['id'] + '"]').each(function () {
                                $(this).replaceWith($(this).html());

                            });


                            if (lt_showProgressBar == true) {
                                var progress_issues = $(sgfunc['progress_container'].call()).find('progress').next();

                                $(progress_issues).html($(sgfunc['body'].call()).find('.lt-highlight').length + (sgstore.viewport_process == 'disabled' ? '' : '+') + ' Issue(s)');
                            }
                            if ((this.mode || 0) == 1) {
                                lt_nextIssue();
                            }

                            lt_ignoreCallback.call(this, 'addRule', sgstore['lt'][e.data.uuid][e.data.hid]['rule']['id']);

                        }
                    });

                });

            }


        }

    }








    // If the menu element is clicked
    sgdocevents.contextmenu_item_clickHandler = ['click', '.context-menu-item', function () {

        lt_contextMenuClick($(this).data("ident-uuid"), $(this).data("ident-hid"), $(this).data("ident-value"));


        // Hide it AFTER the action was triggered
        $("#context-menu-nav").hide(100);



    }];



    // If the menu element is clicked
    sgdocevents.contextmenu_ignore_clickHandler = ['click', '.context-menu-ignore', function () {
        //lt_debug('INFO|CONTEXT-IGNORE=' + $(this).data("ident-uuid") + '=' + $(this).data("ident-hid") + '=' + $(this).data("ident-value"), 4);


        lt_contextMenuIgnore($(this).data("ident-uuid"), $(this).data("ident-hid"), $(this).data("ident-value"));


        // Hide it AFTER the action was triggered
        $("#context-menu-nav").hide(100);



    }];

    $.each(sgdocevents, function (key, val) {
        if (val[1] == '') {
            $(document).on(val[0], val[2]);
        } else {
            $(document).on(val[0], val[1], val[2]);
        }
    });





    return {
        setStore: setStore,
        getStore: getStore,
        setFunction: setFunction,
        getEvent: getEvent,
        removeRule: removeRule,
        removeWord: removeWord,

        setProgress: setProgress,
        nextIssue: nextIssue,
        setAcceptDialog: setAcceptDialog,
        setIgnoreDialog: setIgnoreDialog,
        setSkipDialog: setSkipDialog,

        manualProcess: manualProcess,

        highlightList: lt_setHighlight
    };

};
